<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#0b1220" />
  <link rel="manifest" href="./manifest.webmanifest" />
  <title>Mini Music Player</title>
  <style>
    :root{
      --bg:#0b1220; --card:#121a2c; --muted:#8ea0bf; --text:#e9f0ff;
      --line:rgba(255,255,255,.08); --accent:#5dd6ff; --accent2:#9bff7a;
      --danger:#ff6b6b;
      --r:18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      background: radial-gradient(1200px 700px at 30% -10%, rgba(93,214,255,.18), transparent 55%),
                  radial-gradient(900px 600px at 90% 0%, rgba(155,255,122,.12), transparent 55%),
                  var(--bg);
      color:var(--text);
    }
    .wrap{max-width:980px; margin:0 auto; padding:14px 12px 40px;}
    .topbar{display:flex; gap:10px; align-items:center; justify-content:space-between; margin-bottom:12px;}
    .brand{display:flex; gap:10px; align-items:center;}
    .logo{width:38px;height:38px;border-radius:12px;background:linear-gradient(135deg, rgba(93,214,255,.9), rgba(155,255,122,.8)); box-shadow:0 10px 30px rgba(0,0,0,.35);}
    h1{font-size:18px; margin:0;}
    .small{color:var(--muted); font-size:12px; line-height:1.35;}
    .seg{
      display:flex; gap:6px; background:rgba(255,255,255,.06); padding:6px; border-radius:999px;
      border:1px solid rgba(255,255,255,.08);
    }
    .seg button{
      border:0; background:transparent; color:var(--muted); padding:8px 12px; border-radius:999px;
      cursor:pointer; font-weight:700;
    }
    .seg button.active{background:rgba(255,255,255,.11); color:var(--text);}
    .grid{display:grid; grid-template-columns: 1.2fr .8fr; gap:12px;}
    @media (max-width:860px){ .grid{grid-template-columns:1fr;} }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.08);
      border-radius: var(--r);
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
      overflow:hidden;
    }
    .cardhead{padding:12px 12px 10px; border-bottom:1px solid var(--line); display:flex; gap:10px; align-items:center; justify-content:space-between;}
    .cardhead .title{font-weight:800;}
    .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
    .btn{
      border:1px solid rgba(255,255,255,.1);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:8px 10px; border-radius:12px;
      cursor:pointer; font-weight:700;
    }
    .btn.primary{border-color:rgba(93,214,255,.45); background: rgba(93,214,255,.12);}
    .btn.danger{border-color:rgba(255,107,107,.45); background: rgba(255,107,107,.12);}
    .btn.small{padding:6px 8px; font-size:12px; border-radius:10px;}
    .pill{display:inline-block; padding:3px 8px; border-radius:999px; background:rgba(255,255,255,.07); border:1px solid rgba(255,255,255,.08); color:var(--muted); font-size:12px;}
    .list{max-height: 56vh; overflow:auto;}
    @media (max-width:860px){ .list{max-height: 48vh;} }
    .item{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      padding:10px 12px; border-bottom:1px solid var(--line);
      cursor:pointer;
    }
    .item:hover{background:rgba(255,255,255,.03)}
    .item.playing{background: rgba(93,214,255,.10);}
    .meta{min-width:0}
    .meta .name{font-weight:800; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .meta .sub{display:flex; gap:6px; flex-wrap:wrap; margin-top:4px;}
    .actions{display:flex; gap:6px; align-items:center; flex-shrink:0;}
    .iconbtn{
      width:34px; height:34px; border-radius:12px; border:1px solid rgba(255,255,255,.1);
      background: rgba(255,255,255,.06); color:var(--text);
      cursor:pointer; font-weight:900; display:grid; place-items:center;
    }
    .iconbtn.mid{width:40px; height:40px; border-radius:14px; font-size:16px;}
    .player{padding:12px;}
    audio{width:100%}
    .pgrid{display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px;}
    @media (max-width:420px){ .pgrid{grid-template-columns:1fr;} }
    .kv{background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:10px;}
    .kv .k{font-size:12px; color:var(--muted);}
    .kv .v{font-weight:900; margin-top:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .toast{
      position: fixed; left:50%; bottom:16px; transform: translateX(-50%);
      background: rgba(18,26,44,.94); border:1px solid rgba(255,255,255,.12);
      padding:10px 12px; border-radius:999px; color:var(--text);
      box-shadow: 0 18px 40px rgba(0,0,0,.45);
      opacity:0; pointer-events:none; transition:opacity .18s ease, transform .18s ease;
      max-width:min(92vw, 700px); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .toast.show{opacity:1; transform: translateX(-50%) translateY(-2px);}
    input[type="search"]{
      width:100%; padding:10px 12px; border-radius:14px;
      border:1px solid rgba(255,255,255,.12); outline:none;
      background: rgba(255,255,255,.04); color:var(--text);
    }
  
    /* ---- layout safety: prevent horizontal overflow on narrow screens ---- */
    html, body { overflow-x: hidden; }
    .wrap { overflow-x: hidden; }
    .card { overflow-x: hidden; }
    .item, .meta, .sub { min-width: 0; }
    .pill{
      max-width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    /* slightly smaller icon buttons on very narrow screens */
    @media (max-width: 380px){
      .iconbtn{ width:30px; height:30px; border-radius:11px; }
      .iconbtn.mid{ width:36px; height:36px; border-radius:13px; }
    }

</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>Mini Music Player</h1>
          <div class="small">Android向け / PWA対応（端末のファイルを選んで再生）</div>
        </div>
      </div>
      <div class="seg" role="tablist" aria-label="view">
        <button id="tabLib" class="active" role="tab">Library</button>
        <button id="tabQ" role="tab">Queue</button>
        <button id="tabPL" role="tab">Playlists</button>
      </div>
    </div>

    <div class="grid">
      <div class="card" id="mainCard">
        <div class="cardhead">
          <div class="title">Now Playing</div>
          <div class="row">
            <button class="iconbtn mid" id="prevBtn" title="前へ">⏮</button>
            <button class="iconbtn mid" id="playBtn" title="再生/停止">▶</button>
            <button class="iconbtn mid" id="nextBtn" title="次へ">⏭</button>
          </div>
        </div>
        <div class="player">
          <audio id="audio" controls playsinline></audio>

          <div class="row" style="margin-top:10px; justify-content:space-between;">
            <div class="row" style="flex-wrap:nowrap; min-width:0">
              <span class="pill" id="npIdx">—</span>
              <span class="pill" id="npArtist">—</span>
              <span class="pill" id="npRel">—</span>
            </div>
            <div class="row">
              <button class="btn small" id="addQBtn" title="今の曲をキューに追加">+Q</button>
              <button class="btn small" id="addPLBtn" title="今の曲をプレイリストに追加">☆</button>
            </div>
          </div>

          <div class="pgrid">
            <div class="kv">
              <div class="k">曲名</div>
              <div class="v" id="npName">—</div>
            </div>
            <div class="kv">
              <div class="k">状態</div>
              <div class="v" id="npState">停止</div>
            </div>
          </div>

          <div class="small" style="margin-top:10px;">
            ヒント：<b>Playlists</b>で「エクスポート」しておけば、端末変更しても復元できるよ。
          </div>
        </div>
      </div>

      <div>
        <div class="card" id="libCard">
          <div class="cardhead">
            <div class="title">Library</div>
            <div class="row">
              <button class="btn primary" id="pickFilesBtn">曲を選ぶ</button>
              <button class="btn primary" id="pickFolderBtn">フォルダ</button>
              <button class="btn" id="restoreFolderBtn" title="記憶したフォルダから復元">復元</button>
              <button class="btn" id="forgetFolderBtn" title="記憶したフォルダを解除">解除</button>
              <button class="btn" id="clearLibBtn">クリア</button>
            </div>
          </div>
          <div style="padding:10px 12px; border-bottom:1px solid var(--line);">
            <input id="search" type="search" placeholder="検索（ファイル名）" />
            <div class="small" style="margin-top:8px;">
              読み込み数：<span id="libCount" class="pill">0</span>
              <span class="pill">※端末の中身はアップロードされない</span>
              <div class="small" style="margin-top:8px;">記憶フォルダ：<span id="folderStatus" class="pill">未設定</span></div>
            </div>
          </div>
          <div class="list" id="libList"></div>
        </div>

        <div class="card" id="qCard" style="display:none; margin-top:12px;">
          <div class="cardhead">
            <div class="title">Queue</div>
            <div class="row">
              <button class="btn" id="qClearBtn">空にする</button>
              <button class="btn" id="qShuffleBtn">シャッフル</button>
            </div>
          </div>
          <div class="list" id="qList"></div>
        </div>

        <div class="card" id="plCard" style="display:none; margin-top:12px;">
          <div class="cardhead">
            <div class="title">Playlists</div>
            <div class="row">
              <button class="btn" id="plNewBtn">新規</button>
              <button class="btn" id="plExportBtn">エクスポート</button>
              <button class="btn" id="plImportBtn">インポート</button>
            </div>
          </div>
          <div style="padding:10px 12px; border-bottom:1px solid var(--line);">
            <div class="small" id="plHint">—</div>
            <div class="row" style="margin-top:8px;">
              <button class="btn small" id="plBackBtn" style="display:none;">← 一覧へ</button>
              <button class="btn small" id="plToQueueBtn" style="display:none;">≡ キューへ</button>
              <button class="btn small" id="plPlayBtn" style="display:none;">▶ 先頭から再生</button>
              <button class="btn small" id="plRenameBtn" style="display:none;">✎ 名前</button>
              <button class="btn small danger" id="plDeleteBtn" style="display:none;">✕ 削除</button>
            </div>
          </div>
          <div class="list" id="plList"></div>
          <div class="list" id="plTracks" style="display:none;"></div>
        </div>

        <input id="fileInput" type="file" accept="audio/*" multiple hidden>
        <input id="folderInput" type="file" accept="audio/*" webkitdirectory multiple hidden>
        <input id="plImportInput" type="file" accept="application/json" hidden>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", ()=> navigator.serviceWorker.register("./sw.js").catch(()=>{}));
  }

  const $ = (q)=>document.querySelector(q);

  const audio = $("#audio");
  const playBtn = $("#playBtn");
  const prevBtn = $("#prevBtn");
  const nextBtn = $("#nextBtn");

  const libCard = $("#libCard");
  const qCard   = $("#qCard");
  const plCard  = $("#plCard");

  const libList = $("#libList");
  const qList   = $("#qList");
  const plList  = $("#plList");
  const plTracks= $("#plTracks");

  const search  = $("#search");
  const fileInput   = $("#fileInput");
  const folderInput = $("#folderInput");

  const restoreFolderBtn = $("#restoreFolderBtn");
  const forgetFolderBtn = $("#forgetFolderBtn");
  const folderStatus = $("#folderStatus");

  // ---- Remembered folder (A) ----
  // Uses File System Access API when available (Chrome/Android supports it on many versions).
  // We store the directory handle in IndexedDB so it can be reused next launch.
  const DB_NAME = "mini-player-db";
  const DB_STORE = "kv";
  const DB_KEY_DIR = "musicDirHandle_v1";

  function idbOpen(){
    return new Promise((resolve,reject)=>{
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = ()=> {
        const db = req.result;
        if (!db.objectStoreNames.contains(DB_STORE)) db.createObjectStore(DB_STORE);
      };
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
    });
  }
  async function idbGet(key){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(DB_STORE, "readonly");
      const st = tx.objectStore(DB_STORE);
      const req = st.get(key);
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
      tx.oncomplete = ()=> db.close();
    });
  }
  async function idbSet(key, val){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(DB_STORE, "readwrite");
      const st = tx.objectStore(DB_STORE);
      const req = st.put(val, key);
      req.onsuccess = ()=> resolve(true);
      req.onerror = ()=> reject(req.error);
      tx.oncomplete = ()=> db.close();
    });
  }
  async function idbDel(key){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(DB_STORE, "readwrite");
      const st = tx.objectStore(DB_STORE);
      const req = st.delete(key);
      req.onsuccess = ()=> resolve(true);
      req.onerror = ()=> reject(req.error);
      tx.oncomplete = ()=> db.close();
    });
  }

  function supportsDirHandle(){
    return !!window.showDirectoryPicker;
  }

  const AUDIO_EXT = new Set(["mp3","m4a","aac","wav","flac","ogg","opus","mp4","webm"]);
  function isAudioLike(name, type){
    if (type && type.startsWith("audio/")) return true;
    const m = (name||"").toLowerCase().match(/\.([a-z0-9]+)$/);
    return m ? AUDIO_EXT.has(m[1]) : false;
  }

  async function scanDir(dirHandle){
    // Collect audio files recursively (depth-first).
    const found = [];
    async function walk(handle, rel){
      for await (const [name, h] of handle.entries()){
        if (h.kind === "file"){
          try{
            const file = await h.getFile();
            if (!isAudioLike(name, file.type)) continue;
            // add path info for display
            const t = parseFileToTrack(file, rel || "");
            found.push(t);
          }catch{}
        }else if (h.kind === "directory"){
          // skip hidden folders to reduce noise
          if ((name||"").startsWith(".")) continue;
          await walk(h, rel ? (rel + "/" + name) : name);
        }
        // soft limit to avoid freezing on huge libraries
        if (found.length >= 4000) return;
      }
    }
    await walk(dirHandle, "");
    return found;
  }

  async function updateFolderStatus(){
    let s = "未設定";
    if (!supportsDirHandle()){
      s = "未対応（通常フォルダ選択）";
      folderStatus.textContent = s;
      restoreFolderBtn.disabled = true;
      forgetFolderBtn.disabled = true;
      return;
    }
    try{
      const h = await idbGet(DB_KEY_DIR);
      if (!h){
        folderStatus.textContent = "未設定";
        restoreFolderBtn.disabled = true;
        forgetFolderBtn.disabled = true;
        return;
      }
      // We don't know folder name reliably; show "設定済み"
      const perm = await h.queryPermission({mode:"read"}).catch(()=> "prompt");
      const nm = (h && h.name) ? h.name : "フォルダ";
      folderStatus.textContent = perm === "granted" ? `${nm}（設定済み）` : `${nm}（要許可）`;
      restoreFolderBtn.disabled = false;
      forgetFolderBtn.disabled = false;
    }catch{
      folderStatus.textContent = "未設定";
      restoreFolderBtn.disabled = true;
      forgetFolderBtn.disabled = true;
    }
  }

  async function rememberFolderAndLoad(){
    if (!supportsDirHandle()){
      // fallback: regular folder input (not persistent)
      folderInput.click();
      return;
    }
    try{
      const dir = await window.showDirectoryPicker({ mode: "read" });
      // ask for permission now
      const perm = await dir.requestPermission({mode:"read"}).catch(()=> "prompt");
      if (perm !== "granted"){
        toast("フォルダの許可が必要");
        return;
      }
      // try to make storage persistent (best effort)
      if (navigator.storage && navigator.storage.persist) {
        try{ await navigator.storage.persist(); }catch{}
      }
      await idbSet(DB_KEY_DIR, dir);
      await updateFolderStatus();

      toast("フォルダを記憶して読み込み中…");
      const found = await scanDir(dir);
      tracks = found;
      $("#libCount").textContent = String(tracks.length);
      // reset queue to library if empty or mismatch
      queue = tracks.map(t=>t.id);
      renderLibrary();
      renderQueue();
      if (queue.length) setCurrent(queue[0], {autoplay:false});
      toast(`復元：${tracks.length}曲`);
    }catch(e){
      toast("フォルダ選択をキャンセル");
    }
  }

  async function restoreRememberedFolder(){
    if (!supportsDirHandle()){
      toast("この端末は記憶フォルダ復元が未対応。フォルダを選んでね。");
      folderInput.click();
      return;
    }
    const dir = await idbGet(DB_KEY_DIR);
    if (!dir){
      toast("記憶フォルダがない（まずフォルダを選んでね）");
      return;
    }
    let perm = await dir.queryPermission({mode:"read"}).catch(()=> "prompt");
    if (perm !== "granted"){
      perm = await dir.requestPermission({mode:"read"}).catch(()=> "prompt");
    }
    if (perm !== "granted"){
      toast("許可が必要（もう一回「フォルダ」で選び直してもOK）");
      await updateFolderStatus();
      return;
    }
    toast("記憶フォルダから復元中…");
    const found = await scanDir(dir);
    tracks = found;
    $("#libCount").textContent = String(tracks.length);
    queue = tracks.map(t=>t.id);
    renderLibrary();
    renderQueue();
    if (queue.length) setCurrent(queue[0], {autoplay:false});
    toast(`復元：${tracks.length}曲`);
    await updateFolderStatus();
  }

  async function forgetRememberedFolder(){
    if (!confirm("記憶したフォルダを解除する？")) return;
    await idbDel(DB_KEY_DIR);
    await updateFolderStatus();
    toast("解除した");
  }

  // Hook buttons
  restoreFolderBtn?.addEventListener("click", ()=> restoreRememberedFolder());
  forgetFolderBtn?.addEventListener("click", ()=> forgetRememberedFolder());

  const toastEl = $("#toast");

  const npIdx    = $("#npIdx");
  const npName   = $("#npName");
  const npArtist = $("#npArtist");
  const npRel    = $("#npRel");
  const npState  = $("#npState");

  let tracks = [];
  let queue = [];
  let currentId = null;
  let currentUrl = null;

  const mkId = ()=> Math.random().toString(36).slice(2,10) + Date.now().toString(36);
  const escapeHtml = (s)=> (s??"").toString().replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add("show");
    clearTimeout(toastEl._t);
    toastEl._t = setTimeout(()=> toastEl.classList.remove("show"), 1400);
  }

  function setTab(which){
    const lib = which==="lib", q = which==="q", pl = which==="pl";
    $("#tabLib").classList.toggle("active", lib);
    $("#tabQ").classList.toggle("active", q);
    $("#tabPL").classList.toggle("active", pl);
    libCard.style.display = lib ? "" : "none";
    qCard.style.display   = q   ? "" : "none";
    plCard.style.display  = pl  ? "" : "none";
  }

  function fnv1a36(str){
    let h = 2166136261;
    for (let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return (h >>> 0).toString(36);
  }
  function stableTrackId(file, rel){
    const key = `${rel||""}|${file.name||""}|${file.size||0}|${file.lastModified||0}`;
    return fnv1a36(key);
  }
  function parseFileToTrack(file, relOverride){
    const rel = (relOverride !== undefined)
      ? (relOverride||"")
      : (file.webkitRelativePath ? file.webkitRelativePath.split("/").slice(0,-1).join("/") : "");
    const base = file.name.replace(/\.[^.]+$/, "");
    let artist = "";
    let name = base;
    const m = base.match(/^\s*(.+?)\s*-\s*(.+?)\s*$/);
    if (m){ artist = m[1].trim(); name = m[2].trim(); }
    return { id: stableTrackId(file, rel), name, artist, rel, file };
  }

  function loadFiles(fileList){
    const arr = Array.from(fileList || []).filter(f=> f && f.type && f.type.startsWith("audio/"));
    if (!arr.length){ toast("音声ファイルがない"); return; }
    const newTracks = arr.map(parseFileToTrack);
    tracks.push(...newTracks);
    $("#libCount").textContent = String(tracks.length);

    if (!queue.length) queue = tracks.map(t=>t.id);
    renderLibrary();
    renderQueue();
    if (!currentId && queue.length) setCurrent(queue[0], {autoplay:false});
    toast(`読み込み：${newTracks.length}曲`);
  }

  $("#pickFilesBtn").addEventListener("click", ()=> fileInput.click());
  $("#pickFolderBtn").addEventListener("click", ()=> rememberFolderAndLoad());
  fileInput.addEventListener("change", (e)=>{ loadFiles(e.target.files); fileInput.value=""; });
  folderInput.addEventListener("change", (e)=>{ loadFiles(e.target.files); folderInput.value=""; });

  $("#clearLibBtn").addEventListener("click", ()=>{
    if (!confirm("ライブラリを全部クリアする？")) return;
    stopAndRevoke();
    tracks = []; queue = []; currentId = null;
    $("#libCount").textContent = "0";
    renderLibrary(); renderQueue(); updateNowPlaying();
    toast("クリアした");
  });

  function stopAndRevoke(){
    try{ audio.pause(); }catch{}
    if (currentUrl){ URL.revokeObjectURL(currentUrl); currentUrl = null; }
  }

  function setCurrent(id, {autoplay=true}={}){
    const t = tracks.find(x=>x.id===id);
    if (!t) return;
    currentId = id;

    stopAndRevoke();
    currentUrl = URL.createObjectURL(t.file);
    audio.src = currentUrl;

    updateNowPlaying();
  // remembered folder status (A)
  updateFolderStatus();
  // auto-restore if already permitted
  (async()=>{ try{ const h = supportsDirHandle()? await idbGet(DB_KEY_DIR): null; if(h){ const p = await h.queryPermission({mode:"read"}).catch(()=>"prompt"); if(p==="granted"){ restoreRememberedFolder(); } } }catch{} })();
    renderLibrary();
    renderQueue();
    renderPlaylists();

    if (autoplay) audio.play().catch(()=>{});
  }

  function updateNowPlaying(){
    const t = tracks.find(x=>x.id===currentId) || null;
    npIdx.textContent = t ? `#${queue.indexOf(currentId)+1}/${queue.length||tracks.length||0}` : "—";
    npName.textContent = t ? t.name : "—";
    npArtist.textContent = t ? (t.artist || "Unknown") : "—";
    npRel.textContent = t ? (t.rel ? `/${t.rel}` : "/") : "—";
  }

  function playPause(){
    if (!currentId){
      if (queue.length) setCurrent(queue[0], {autoplay:true});
      else if (tracks.length) setCurrent(tracks[0].id, {autoplay:true});
      else { toast("曲を読み込んでね"); return; }
    }
    if (audio.paused) audio.play().catch(()=>{});
    else audio.pause();
  }

  playBtn.addEventListener("click", playPause);
  prevBtn.addEventListener("click", ()=>{
    if (!queue.length) return;
    const i = queue.indexOf(currentId);
    const ni = (i<=0) ? queue.length-1 : i-1;
    setCurrent(queue[ni], {autoplay:true});
  });
  nextBtn.addEventListener("click", ()=>{
    if (!queue.length) return;
    const i = queue.indexOf(currentId);
    const ni = (i<0 || i===queue.length-1) ? 0 : i+1;
    setCurrent(queue[ni], {autoplay:true});
  });

  audio.addEventListener("play", ()=>{ playBtn.textContent="⏸"; npState.textContent="再生中"; });
  audio.addEventListener("pause", ()=>{ playBtn.textContent="▶"; npState.textContent="停止"; });
  audio.addEventListener("ended", ()=>{ nextBtn.click(); });

  $("#addQBtn").addEventListener("click", ()=>{
    if (!currentId){ toast("曲を選んでね"); return; }
    queue.push(currentId);
    renderQueue();
    toast("キューに追加");
  });

  function mkIconBtn(txt, title, onClick){
    const b = document.createElement("button");
    b.className = "iconbtn";
    b.textContent = txt;
    b.title = title;
    b.addEventListener("click", onClick);
    return b;
  }

  function renderLibrary(){
    const q = (search.value||"").trim().toLowerCase();
    const list = q ? tracks.filter(t => (t.file?.name||"").toLowerCase().includes(q) || (t.name||"").toLowerCase().includes(q) || (t.artist||"").toLowerCase().includes(q) )
                   : tracks;

    libList.innerHTML = "";
    if (!list.length){
      libList.innerHTML = `<div class="small" style="padding:12px;">曲を読み込むとここに出るよ。</div>`;
      return;
    }

    for (const t of list){
      const row = document.createElement("div");
      row.className = "item" + (t.id===currentId ? " playing" : "");
      row.addEventListener("click", ()=> setCurrent(t.id, {autoplay:true}));

      const meta = document.createElement("div");
      meta.className = "meta";
      meta.innerHTML = `
        <div class="name">${escapeHtml(t.name)}</div>
        <div class="sub">
          <span class="pill">${escapeHtml(t.artist||"Unknown")}</span>
          <span class="pill">${escapeHtml(t.file?.name||"")}</span>
        </div>
      `;

      const actions = document.createElement("div");
      actions.className = "actions";

      const bPlay = mkIconBtn("▶","再生",(e)=>{ e.stopPropagation(); setCurrent(t.id,{autoplay:true}); });
      const bQ = mkIconBtn("+","キューへ",(e)=>{ e.stopPropagation(); queue.push(t.id); renderQueue(); toast("キューに追加"); });
      const bPL = mkIconBtn("☆","プレイリストに追加",(e)=>{ e.stopPropagation(); addTrackToPlaylist(t.id); });

      actions.append(bPlay,bQ,bPL);
      row.append(meta, actions);
      libList.appendChild(row);
    }
  }

  function renderQueue(){
    qList.innerHTML = "";
    if (!queue.length){
      qList.innerHTML = `<div class="small" style="padding:12px;">キューは空。Libraryの「+」で追加できるよ。</div>`;
      return;
    }
    queue.forEach((id, idx)=>{
      const t = tracks.find(x=>x.id===id);
      const name = t ? t.name : "(見つからない)";
      const artist = t ? (t.artist||"Unknown") : "—";
      const row = document.createElement("div");
      row.className = "item" + (id===currentId ? " playing" : "");
      row.addEventListener("click", ()=>{ if(t) setCurrent(id,{autoplay:true}); });

      const meta = document.createElement("div");
      meta.className="meta";
      meta.innerHTML = `
        <div class="name">${escapeHtml(name)}</div>
        <div class="sub">
          <span class="pill">${idx+1}</span>
          <span class="pill">${escapeHtml(artist)}</span>
        </div>
      `;
      const actions = document.createElement("div");
      actions.className="actions";
      const bDel = mkIconBtn("✕","この曲を削除",(e)=>{
        e.stopPropagation();
        queue.splice(idx,1);
        renderQueue();
        updateNowPlaying();
  // remembered folder status (A)
  updateFolderStatus();
  // auto-restore if already permitted
  (async()=>{ try{ const h = supportsDirHandle()? await idbGet(DB_KEY_DIR): null; if(h){ const p = await h.queryPermission({mode:"read"}).catch(()=>"prompt"); if(p==="granted"){ restoreRememberedFolder(); } } }catch{} })();
      });
      actions.append(bDel);
      row.append(meta, actions);
      qList.appendChild(row);
    });
  }

  $("#qClearBtn").addEventListener("click", ()=>{
    if (!confirm("キューを空にする？")) return;
    queue = [];
    renderQueue();
    updateNowPlaying();
  // remembered folder status (A)
  updateFolderStatus();
  // auto-restore if already permitted
  (async()=>{ try{ const h = supportsDirHandle()? await idbGet(DB_KEY_DIR): null; if(h){ const p = await h.queryPermission({mode:"read"}).catch(()=>"prompt"); if(p==="granted"){ restoreRememberedFolder(); } } }catch{} })();
    toast("キューを空にした");
  });
  $("#qShuffleBtn").addEventListener("click", ()=>{
    for (let i=queue.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [queue[i],queue[j]] = [queue[j],queue[i]];
    }
    renderQueue();
    toast("シャッフル");
  });

  search.addEventListener("input", renderLibrary);

  // ===== Playlists =====
  const PL_KEY = "miniPlayer.playlists.v1";
  let playlists = { order: [], byId: {}, selectedId: null };

  function loadPlaylists(){
    try{
      const raw = localStorage.getItem(PL_KEY);
      if (!raw) return;
      const obj = JSON.parse(raw);
      if (obj && Array.isArray(obj.order) && obj.byId && typeof obj.byId==="object") playlists = obj;
    }catch{}
  }
  function savePlaylists(){
    try{ localStorage.setItem(PL_KEY, JSON.stringify(playlists)); }catch{}
  }

  function makeHint(t){
    return { name: t.name, artist: t.artist||"", rel: t.rel||"", fileName: t.file?.name||"" };
  }
  function findByHint(h){
    if (!h) return null;
    return tracks.find(t => (t.rel||"")===(h.rel||"") && (t.file?.name||"")===(h.fileName||""))
        || tracks.find(t => (t.file?.name||"")===(h.fileName||""))
        || tracks.find(t => (t.name||"")===(h.name||"") && (t.artist||"")===(h.artist||""))
        || null;
  }

  function createPlaylist(name){
    const id = mkId();
    playlists.byId[id] = { id, name: name || "New Playlist", items: [], createdAt: Date.now(), updatedAt: Date.now() };
    playlists.order.push(id);
    playlists.selectedId = id;
    savePlaylists();
    toast("プレイリスト作成");
    renderPlaylists();
    openPlaylist(id);
  }

  function openPlaylist(id){
    const pl = playlists.byId[id];
    if (!pl) return;
    playlists.selectedId = id;
    savePlaylists();

    $("#plBackBtn").style.display="";
    $("#plToQueueBtn").style.display="";
    $("#plPlayBtn").style.display="";
    $("#plRenameBtn").style.display="";
    $("#plDeleteBtn").style.display="";

    $("#plHint").textContent = `開いてる：${pl.name}（☆で追加）`;
    plList.style.display="none";
    plTracks.style.display="";

    plTracks.innerHTML = "";
    if (!pl.items.length){
      plTracks.innerHTML = `<div class="small" style="padding:12px;">空だよ。再生中かLibraryで「☆」して追加してね。</div>`;
      return;
    }

    pl.items.forEach((h, idx)=>{
      const t = findByHint(h);
      const row = document.createElement("div");
      row.className="item" + (t?.id===currentId ? " playing" : "");
      row.addEventListener("click", ()=>{
        if (!t){ toast("この曲はまだ読み込まれてない"); return; }
        setCurrent(t.id,{autoplay:true});
      });

      const meta = document.createElement("div");
      meta.className="meta";
      meta.innerHTML = `
        <div class="name">${escapeHtml(h.name || h.fileName || "Unknown")}</div>
        <div class="sub">
          <span class="pill">${escapeHtml(h.artist||"Unknown")}</span>
          <span class="pill">${t ? "OK" : "未読込"}</span>
        </div>
      `;

      const actions = document.createElement("div");
      actions.className="actions";
      const bDel = mkIconBtn("✕","削除",(e)=>{
        e.stopPropagation();
        const pl2 = playlists.byId[id];
        if (!pl2) return;
        pl2.items.splice(idx,1);
        pl2.updatedAt = Date.now();
        savePlaylists();
        openPlaylist(id);
      });
      actions.append(bDel);
      row.append(meta, actions);
      plTracks.appendChild(row);
    });
  }

  function closePlaylist(){
    $("#plBackBtn").style.display="none";
    $("#plToQueueBtn").style.display="none";
    $("#plPlayBtn").style.display="none";
    $("#plRenameBtn").style.display="none";
    $("#plDeleteBtn").style.display="none";

    plTracks.style.display="none";
    plList.style.display="";
    renderPlaylists();
  }

  function renderPlaylists(){
    const sel = playlists.selectedId;
    const selName = sel ? (playlists.byId[sel]?.name||"") : "";
    $("#plHint").textContent = playlists.order.length
      ? (sel ? `選択中：${selName}（☆で追加）` : "プレイリストを選ぶと☆で追加できる")
      : "まだプレイリストがないよ。まず「新規」";

    plList.innerHTML = "";
    if (!playlists.order.length){
      plList.innerHTML = `<div class="small" style="padding:12px;">「新規」でプレイリストを作ろう。</div>`;
      return;
    }

    playlists.order.forEach((id)=>{
      const pl = playlists.byId[id];
      if (!pl) return;
      const row = document.createElement("div");
      row.className = "item" + (id===sel ? " playing" : "");
      row.addEventListener("click", ()=> openPlaylist(id));

      const meta = document.createElement("div");
      meta.className="meta";
      meta.innerHTML = `
        <div class="name">${escapeHtml(pl.name)}</div>
        <div class="sub">
          <span class="pill">${pl.items.length}曲</span>
          <span class="pill">${id===sel ? "選択中" : "タップで開く"}</span>
        </div>
      `;
      const actions = document.createElement("div");
      actions.className="actions";
      const bQ = mkIconBtn("≡","キューへ",(e)=>{ e.stopPropagation(); playlistToQueue(id,{autoplay:false}); });
      const bP = mkIconBtn("▶","再生",(e)=>{ e.stopPropagation(); playlistToQueue(id,{autoplay:true}); });
      actions.append(bQ,bP);
      row.append(meta, actions);
      plList.appendChild(row);
    });
  }

  function addTrackToPlaylist(trackId){
    const plId = playlists.selectedId;
    if (!plId){
      toast("先にプレイリストを選んでね");
      setTab("pl");
      return;
    }
    const pl = playlists.byId[plId];
    const t = tracks.find(x=>x.id===trackId);
    if (!pl || !t) return;
    pl.items.push(makeHint(t));
    pl.updatedAt = Date.now();
    savePlaylists();
    toast("プレイリストに追加");
    if (plTracks.style.display !== "none") openPlaylist(plId);
    else renderPlaylists();
  }

  function playlistToQueue(plId, {autoplay=false}={}){
    const pl = playlists.byId[plId];
    if (!pl) return;
    let missing = 0;
    const ids = [];
    for (const h of pl.items){
      const t = findByHint(h);
      if (t) ids.push(t.id);
      else missing++;
    }
    if (!ids.length){
      toast("一致する曲がない（先に曲を読み込んでね）");
      return;
    }
    queue = ids.slice();
    renderQueue();
    if (autoplay) setCurrent(queue[0], {autoplay:true});
    toast(missing ? `展開OK（未読込:${missing}）` : "キューへ展開");
    setTab("q");
  }

  function exportPlaylists(){
    const payload = { version:1, exportedAt: new Date().toISOString(), data: playlists };
    const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "mini-player-playlists.json";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    toast("エクスポートした");
  }

  function importPlaylistsText(text){
    let obj;
    try{ obj = JSON.parse(text); }catch{ toast("JSONが壊れてる"); return; }
    const incoming = obj?.data?.byId ? obj.data : (obj?.byId ? obj : null);
    if (!incoming || !Array.isArray(incoming.order) || !incoming.byId){ toast("形式が違うっぽい"); return; }

    let added = 0;
    for (const oldId of incoming.order){
      const pl = incoming.byId[oldId];
      if (!pl) continue;
      const id = mkId();
      playlists.byId[id] = {
        id,
        name: (pl.name || "Imported").toString(),
        items: Array.isArray(pl.items) ? pl.items.filter(Boolean) : [],
        createdAt: Date.now(),
        updatedAt: Date.now()
      };
      playlists.order.push(id);
      added++;
      if (!playlists.selectedId) playlists.selectedId = id;
    }
    savePlaylists();
    renderPlaylists();
    toast(`インポート完了（${added}件）`);
  }

  $("#plNewBtn").addEventListener("click", ()=>{
    const n = prompt("プレイリスト名", "My Playlist");
    if (!n) return;
    createPlaylist(n.trim());
    setTab("pl");
  });
  $("#plExportBtn").addEventListener("click", exportPlaylists);

  const plImportInput = $("#plImportInput");
  $("#plImportBtn").addEventListener("click", ()=> plImportInput.click());
  plImportInput.addEventListener("change", async (e)=>{
    const f = e.target.files?.[0];
    if (!f) return;
    const text = await f.text();
    importPlaylistsText(text);
    plImportInput.value = "";
  });

  $("#plBackBtn").addEventListener("click", closePlaylist);
  $("#plToQueueBtn").addEventListener("click", ()=>{
    const id = playlists.selectedId;
    if (!id) return;
    playlistToQueue(id, {autoplay:false});
  });
  $("#plPlayBtn").addEventListener("click", ()=>{
    const id = playlists.selectedId;
    if (!id) return;
    playlistToQueue(id, {autoplay:true});
  });
  $("#plRenameBtn").addEventListener("click", ()=>{
    const id = playlists.selectedId;
    const pl = playlists.byId[id];
    if (!pl) return;
    const n = prompt("プレイリスト名", pl.name);
    if (!n) return;
    pl.name = n.trim();
    pl.updatedAt = Date.now();
    savePlaylists();
    if (plTracks.style.display !== "none") openPlaylist(id);
    else renderPlaylists();
  });
  $("#plDeleteBtn").addEventListener("click", ()=>{
    const id = playlists.selectedId;
    const pl = playlists.byId[id];
    if (!pl) return;
    if (!confirm(`削除する？\n${pl.name}`)) return;
    delete playlists.byId[id];
    playlists.order = playlists.order.filter(x=>x!==id);
    playlists.selectedId = playlists.order[0] || null;
    savePlaylists();
    closePlaylist();
    toast("削除した");
  });

  $("#addPLBtn").addEventListener("click", ()=>{
    if (!currentId){ toast("曲を選んでね"); return; }
    addTrackToPlaylist(currentId);
    setTab("pl");
  });

  $("#tabLib").addEventListener("click", ()=> setTab("lib"));
  $("#tabQ").addEventListener("click", ()=> setTab("q"));
  $("#tabPL").addEventListener("click", ()=> setTab("pl"));

  loadPlaylists();
  renderLibrary();
  renderQueue();
  renderPlaylists();
  updateNowPlaying();
  // remembered folder status (A)
  updateFolderStatus();
  // auto-restore if already permitted
  (async()=>{ try{ const h = supportsDirHandle()? await idbGet(DB_KEY_DIR): null; if(h){ const p = await h.queryPermission({mode:"read"}).catch(()=>"prompt"); if(p==="granted"){ restoreRememberedFolder(); } } }catch{} })();
  </script>
</body>
</html>
